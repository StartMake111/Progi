#include <iostream>
#include <vector>
#include <fstream>
#include <random>
using namespace std;

std::ostream &operator<<(std::ostream &print, const std::vector<int> vector)
{
    print << vector.size() << "\t| ";
    for (auto &i : vector)
        print << &i << " ";
    return print << "\n";
}
/* Вопрос 1
    Адреса первых элементов всегда разные потомо что вектор копируется в новую память при вызову << 
    Адрес следующих это адрус предыдущего + sizeof int чтобы элементы находились друг за другом*/
/* Вопрос 2
    Если элемент адреса при длине 15 попытаться изменить при длине 25, то ничего не изменится
    так как весь массив находится в новой памяти. -> вопрос 4 */
/* Вопрос 3
    Ответ тот же что и на вопрос 1 */
/* Вопрос 4
    Оператор << не копирует, если принимает по значению. Когда удаляется элемент вектора, 
    адрес первого элемента не меняется а при добавлении адреса новых элементов псевдо случайны.
    Вектор использует аллокацию памяти в куче. Для этого нужно знать размер аллоцируемых байт
    Колличество аллонированных байт является емкостью вектора. Если длина меньше емкости то некоторое
    аллоцированное место не используется 
    Вектор аллоцирует место для всех элементов. Если добавить элемент в вектор
    и длина равна емкости, то вектор аллоцирует в новую память, с емкостью на sizeof int байт больше
    и затем копирует из старой памяти в новую все элементы вектора, 
    затем удоляет ветор из старой памяти. 
    В случае удаления элемента, то перемещения в новую память необходимости нет.
    Вместо этого уменьшается длина вектора а емкость остается прежней
    По этой причине адрес первого элемента всегда одинаков*/
int main()
{
    vector<int> vec;
    std::ofstream file;
    file.open("datawith.txt");
    cout << file.is_open();
    if (file.is_open())
    {
        for (int i = 0; i < 64; i++)
        {
            vec.push_back(rand());
            file << vec;
        }
        for (int i = 0; i < 64; i++)
        {
            vec.pop_back();
            file << vec;
        }
        for (int i = 0; i < 64; i++)
        {
            vec.push_back(rand());
            file << vec;
        }
        for (int i = 0; i < 64; i++)
        {
            vec.pop_back();
            file << vec;
        }
    }
    file.close();
}